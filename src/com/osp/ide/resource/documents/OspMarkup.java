package com.osp.ide.resource.documents;

import java.io.File;
import java.io.IOException;
import java.io.StringWriter;
import java.util.Locale;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.swt.graphics.Color;
import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

import com.osp.ide.resource.Activator;
import com.osp.ide.resource.common.OspUIFile;
import com.osp.ide.resource.resinfo.BUTTON_INFO;
import com.osp.ide.resource.resinfo.CHECK_INFO;
import com.osp.ide.resource.resinfo.COLORPICKER_INFO;
import com.osp.ide.resource.resinfo.CUSTOMLIST_INFO;
import com.osp.ide.resource.resinfo.DATEPICKER_INFO;
import com.osp.ide.resource.resinfo.EDITAREA_INFO;
import com.osp.ide.resource.resinfo.EDITFIELD_INFO;
import com.osp.ide.resource.resinfo.EXPANDABLELIST_INFO;
import com.osp.ide.resource.resinfo.FLASHCONTROL_INFO;
import com.osp.ide.resource.resinfo.FrameConst;
import com.osp.ide.resource.resinfo.GROUPEDLIST_INFO;
import com.osp.ide.resource.resinfo.ICONLIST_INFO;
import com.osp.ide.resource.resinfo.ITEM_INFO;
import com.osp.ide.resource.resinfo.LABEL_INFO;
import com.osp.ide.resource.resinfo.LIST_INFO;
import com.osp.ide.resource.resinfo.OVERLAYPANEL_INFO;
import com.osp.ide.resource.resinfo.PANEL_INFO;
import com.osp.ide.resource.resinfo.PROGRESS_INFO;
import com.osp.ide.resource.resinfo.SLIDABLEGROUPEDLIST_INFO;
import com.osp.ide.resource.resinfo.SLIDABLELIST_INFO;
import com.osp.ide.resource.resinfo.SLIDER_INFO;
import com.osp.ide.resource.resinfo.TIMEPICKER_INFO;
import com.osp.ide.resource.resourceexplorer.ResourceExplorer;

public abstract class OspMarkup implements FrameConst {

	protected static final String DTD_FOLDER = "template/";
	protected static final String DTD_NAME = "UIForm.dtd";
	
	protected static final String MODIFY_WORNING = 
        "\tThis XML file was automatically generated by UiBuilder - do not modify by hand.";

	protected IFile m_file = null;
	protected OspUIFile m_myFile;

	protected String m_project = "";
	protected String m_dVersion;
	protected String m_bVersion;
	protected String m_Screen = "";

	public OspMarkup() {
		m_myFile = new OspUIFile();
		m_bVersion = Activator.getBVersion();
	}

	public int getTagIndex(String s) {
		for (int i = 0; i < CTL_TYPE_NUM; i++) {
			if (cszCtlType[i].equals(s.toUpperCase(Locale.getDefault())))
				return i;
		}
		return -1;
	}

	public int getAttrIndex(String attr) {
		for (int i = 0; i < cszAttribName.length; i++) {
			if (attr.equals(cszAttribName[i]))
				return i;
		}
		return -1;
	}

	protected static String getAttrValue(Node node, String string) {
		Node item = node.getAttributes().getNamedItem(string);
		if (item == null)
			return "";
		return item.getNodeValue();
	}

	public String getAbsoluteDir() {
		IProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(
				m_project);
		if (project == null)
			return null;

		ResourceExplorer view = ResourceExplorer.getResourceView();
		if (view == null)
			return null;
		String osPath = project.getLocation().toFile().getAbsolutePath();
		osPath += view.getResourceDir();
		return osPath;
	}

    /**
     * @param name
     * @return
     */
    protected String getBmpPath(String name) {
        String path = getAbsoluteDir();
        File file = new File(path + name);
        
        if(file == null || !file.exists())
            return null;
        else
            return name;
    }

	protected boolean isScotia() {
		return m_Screen  != null && m_Screen.toUpperCase(Locale.getDefault()).equals(ResourceExplorer.WQVGA);
	}

    /**
     * @param index
     * @return
     */
    protected ITEM_INFO newContainerItemInfo(int index) {
        ITEM_INFO info = null;
        switch (index) {
        case WINDOW_OVERLAYPANEL:
            info = new OVERLAYPANEL_INFO();
            info.type = WINDOW_OVERLAYPANEL;
            break;
        case WINDOW_PANEL:
            info = new PANEL_INFO();
            info.type = WINDOW_PANEL;
            break;
        }
        return info;
    }

    /**
     * @param index
     * @return
     */
    protected ITEM_INFO newControlItemInfo(int index) {
        ITEM_INFO info = null;
        switch (index) {
        case WINDOW_BUTTON:
            info = new BUTTON_INFO();
            info.type = WINDOW_BUTTON;
            break;
        case WINDOW_CHECKBUTTON:
            info = new CHECK_INFO();
            info.type = WINDOW_CHECKBUTTON;
            break;
        case WINDOW_COLORPICKER:
            info = new COLORPICKER_INFO();
            info.type = WINDOW_COLORPICKER;
            break;
        case WINDOW_CUSTOMLIST:
            info = new CUSTOMLIST_INFO();
            info.type = WINDOW_CUSTOMLIST;
            break;
        case WINDOW_DATEPICKER:
        case WINDOW_EDITDATE:
            info = new DATEPICKER_INFO();
            info.type = WINDOW_EDITDATE;
            break;
        case WINDOW_EDITAREA:
            info = new EDITAREA_INFO();
            info.type = WINDOW_EDITAREA;
            break;
        case WINDOW_EDITFIELD:
            info = new EDITFIELD_INFO();
            info.type = WINDOW_EDITFIELD;
            break;
        case WINDOW_EXPANDABLELIST:
            info = new EXPANDABLELIST_INFO();
            info.type = WINDOW_EXPANDABLELIST;
            break;
        case WINDOW_FLASHCONTROL:
            info = new FLASHCONTROL_INFO();
            info.type = WINDOW_FLASHCONTROL;
            break;
        case WINDOW_GROUPEDLIST:
            info = new GROUPEDLIST_INFO();
            info.type = WINDOW_GROUPEDLIST;
            break;
        case WINDOW_ICONLIST:
            info = new ICONLIST_INFO();
            info.type = WINDOW_ICONLIST;
            break;
        case WINDOW_LABEL:
            info = new LABEL_INFO();
            info.type = WINDOW_LABEL;
            break;
        case WINDOW_LIST:
            info = new LIST_INFO();
            info.type = WINDOW_LIST;
            break;
        case WINDOW_PROGRESS:
            info = new PROGRESS_INFO();
            info.type = WINDOW_PROGRESS;
            break;
        case WINDOW_SLIDER:
            info = new SLIDER_INFO();
            info.type = WINDOW_SLIDER;
            break;
        case WINDOW_SLIDABLEGROUPEDLIST:
            info = new SLIDABLEGROUPEDLIST_INFO();
            info.type = WINDOW_SLIDABLEGROUPEDLIST;
            break;
        case WINDOW_SLIDABLELIST:
            info = new SLIDABLELIST_INFO();
            info.type = WINDOW_SLIDABLELIST;
            break;
        case WINDOW_TIMEPICKER:
        case WINDOW_EDITTIME:
            info = new TIMEPICKER_INFO();
            info.type = WINDOW_EDITTIME;
            break;
        }
        return info;
    }

	protected void getControlInfo(Node node, ITEM_INFO info) {

		switch (info.type) {
		case WINDOW_BUTTON:
			BUTTON_INFO buttonInfo = (BUTTON_INFO) info;
			getButtonInfo(node, buttonInfo);
			break;
		case WINDOW_CHECKBUTTON:
			CHECK_INFO checkInfo = (CHECK_INFO) info;
			getCheckInfo(node, checkInfo);
			break;
		case WINDOW_COLORPICKER:
			COLORPICKER_INFO colorpickerInfo = (COLORPICKER_INFO) info;
			getColorPickerInfo(node, colorpickerInfo);
			break;
		case WINDOW_CUSTOMLIST:
			CUSTOMLIST_INFO customInfo = (CUSTOMLIST_INFO) info;
			getCustomListInfo(node, customInfo);
			break;
		case WINDOW_DATEPICKER:
		case WINDOW_EDITDATE:
			DATEPICKER_INFO datepickerInfo = (DATEPICKER_INFO) info;
			getDatePickerInfo(node, datepickerInfo);
			break;
		case WINDOW_EDITAREA:
			EDITAREA_INFO editareaInfo = (EDITAREA_INFO) info;
			getEditAreaIfno(node, editareaInfo);
			break;
		case WINDOW_EDITFIELD:
			EDITFIELD_INFO editfieldInfo = (EDITFIELD_INFO) info;
			getEditFieldInfo(node, editfieldInfo);
			break;
		case WINDOW_EXPANDABLELIST:
			EXPANDABLELIST_INFO expandablelistInfo = (EXPANDABLELIST_INFO) info;
			getExpandableListInfo(node, expandablelistInfo);
			break;
		case WINDOW_FLASHCONTROL:
			FLASHCONTROL_INFO flashcontrol = (FLASHCONTROL_INFO) info;
			getFlashInfo(node, flashcontrol);
			break;
		case WINDOW_GROUPEDLIST:
			GROUPEDLIST_INFO groupedlistinfo = (GROUPEDLIST_INFO) info;
			getGroupedListInfo(node, groupedlistinfo);
			break;
		case WINDOW_ICONLIST:
			ICONLIST_INFO iconlistinfo = (ICONLIST_INFO) info;
			getIconListInfo(node, iconlistinfo);
			break;
		case WINDOW_LABEL:
			LABEL_INFO labelInfo = (LABEL_INFO) info;
			getLabelIfno(node, labelInfo);
			break;
		case WINDOW_LIST:
			LIST_INFO listInfo = (LIST_INFO) info;
			getListInfo(node, listInfo);
			break;
		case WINDOW_OVERLAYPANEL:
			OVERLAYPANEL_INFO overlaypanelinfo = (OVERLAYPANEL_INFO) info;
			getOverlayPanelInfo(node, overlaypanelinfo);
			break;
		case WINDOW_PANEL:
			PANEL_INFO panelinfo = (PANEL_INFO) info;
			getPanelInfo(node, panelinfo);
			break;
		case WINDOW_PROGRESS:
			PROGRESS_INFO progressInfo = (PROGRESS_INFO) info;
			getProgressInfo(node, progressInfo);
			break;
		case WINDOW_SLIDABLEGROUPEDLIST:
			SLIDABLEGROUPEDLIST_INFO sglistInfo = (SLIDABLEGROUPEDLIST_INFO) info;
			getSGListInfo(node, sglistInfo);
			break;
		case WINDOW_SLIDABLELIST:
			SLIDABLELIST_INFO slistInfo = (SLIDABLELIST_INFO) info;
			getSListInfo(node, slistInfo);
			break;
		case WINDOW_SLIDER:
			SLIDER_INFO slideInfo = (SLIDER_INFO) info;
			getSliderInfo(node, slideInfo);
			break;
		case WINDOW_TIMEPICKER:
		case WINDOW_EDITTIME:
			TIMEPICKER_INFO timepickerInfo = (TIMEPICKER_INFO) info;
			getTimepickerInfo(node, timepickerInfo);
			break;
		default:
			break;
		}
	}

	private void getButtonInfo(Node parent, BUTTON_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;
		String s;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.text = getAttrValue(node, cszAttribName[TEXT]);

				info.hAlign = getAttrValue(node, cszAttribName[HALIGN]);
				if (info.hAlign == null || info.hAlign.isEmpty())
					info.hAlign = cszHAlign[1];
				info.vAlign = getAttrValue(node, cszAttribName[VALIGN]);
				if (info.vAlign == null || info.vAlign.isEmpty())
					info.vAlign = cszVAlign[1];

				s = getAttrValue(node, cszAttribName[NOMALTEXTCOLOR]);
				if (s == null || s.isEmpty())
					info.normalFGColor = DEFAULT_COLOR;
				else
					info.normalFGColor = s;

				s = getAttrValue(node, cszAttribName[PRESSEDTEXTCOLOR]);
				if (s == null || s.isEmpty())
					info.pressedFGColor = DEFAULT_COLOR;
				else
					info.pressedFGColor = s;

				s = getAttrValue(node, cszAttribName[DISABLETEXTCOLOR]);
				if (s == null || s.isEmpty())
					info.disableFGColor = DEFAULT_COLOR;
				else
					info.disableFGColor = s;

//				info.normalBitmapPath = getAttrValue(node,
//						cszAttribName[NORMALBITMAPPATH]);
//
//				info.pressedBitmapPath = getAttrValue(node,
//						cszAttribName[PRESSEDBITMAPPATH]);
//
//				info.disabledBitmapPath = getAttrValue(node,
//						cszAttribName[DISABLEDBITMAPPATH]);

				info.normalBGBitmapPath = getBmpPath(getAttrValue(node,
						cszAttribName[NORMALBGBITMAPPATH]));
				info.pressedBGBitmapPath = getBmpPath(getAttrValue(node,
						cszAttribName[PRESSEDBGBITMAPPATH]));
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getCheckInfo(Node parent, CHECK_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;
		int value;
		String s;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.text = getAttrValue(node, cszAttribName[TEXT]);
				s = getAttrValue(node, cszAttribName[GROUPID]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				info.GroupID = value;
				
                s = getAttrValue(node, cszAttribName[COLOROFTEXT]);
                if (s == null || s.isEmpty())
                    info.textColor = DEFAULT_COLOR;
                else
                    info.textColor = s;
                
                info.groupStyle = getAttrValue(node,
                    cszAttribName[GROUPSTYLE]);
                if(info.groupStyle == null || info.groupStyle.isEmpty())
                    info.groupStyle = cszGroupStyle[GROUP_STYLE_NONE];
            
				s = getAttrValue(node, cszAttribName[BACKGROUNDSTYLE]);
				if (!info.groupStyle.equals(cszGroupStyle[GROUP_STYLE_NONE])) {
	                s = cszBgStyle[BACKGROUND_STYLE_DEFAULT];
				}
				info.BgStyle = s;
				
				if(info.BgStyle == null || info.BgStyle.isEmpty())
					info.BgStyle = cszBgStyle[BACKGROUND_STYLE_NONE];
				
				info.titleText = getAttrValue(node, cszAttribName[TITLETEXT]);
                s = getAttrValue(node, cszAttribName[COLOROFTITLETEXT]);
                if (s == null || s.isEmpty())
                    info.titleTextColor = DEFAULT_COLOR;
                else
                    info.titleTextColor = s;
                
				info.ShowTitleText = getAttrValue(node,
						cszAttribName[SHOWTITLETEXT]);
				if(info.ShowTitleText == null || info.ShowTitleText.isEmpty())
					info.ShowTitleText = "FALSE";
				info.hAlign = getAttrValue(node, cszAttribName[HALIGN]);
				if (info.hAlign == null || info.hAlign.isEmpty())
					info.hAlign = cszHAlign[0];
				info.vAlign = getAttrValue(node, cszAttribName[VALIGN]);
				if (info.vAlign == null || info.vAlign.isEmpty())
					info.vAlign = cszVAlign[0];
//				info.BorderStyle = getAttrValue(node,
//						cszAttribName[BORDERSTYLE]);
//				if(info.BorderStyle == null || info.BorderStyle.isEmpty())
//					info.BorderStyle = cszBorderStyle[0];
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getColorPickerInfo(Node parent, COLORPICKER_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getCustomListInfo(Node parent, CUSTOMLIST_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.itemDivider = getAttrValue(node,
						cszAttribName[ITEMDIVIDER]);
                String s = getAttrValue(node, cszAttribName[COLOROFEMPTYLISTTEXT]);
                if (s == null || s.isEmpty())
                    info.colorOfEmptyListText = DEFAULT_COLOR;
                else
                    info.colorOfEmptyListText = s;
				info.textOfEmptyList = getAttrValue(node,
						cszAttribName[TEXTOFEMPTYLIST]);
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getDatePickerInfo(Node parent, DATEPICKER_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.titleText = getAttrValue(node, cszAttribName[TITLETEXT]);
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getEditAreaIfno(Node parent, EDITAREA_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;
		int value;
		String s;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.guideText = getAttrValue(node, cszAttribName[GUIDETEXT]);
				info.text = getAttrValue(node, cszAttribName[TEXT]);
				s = getAttrValue(node, cszAttribName[LIMITLENGTH]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				info.limitLength = value;
				info.inputStyle = getAttrValue(node, cszAttribName[INPUTSTYLE]);
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getEditFieldInfo(Node parent, EDITFIELD_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;
		int value;
		String s;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.guideText = getAttrValue(node, cszAttribName[GUIDETEXT]);
				info.text = getAttrValue(node, cszAttribName[TEXT]);
				s = getAttrValue(node, cszAttribName[LIMITLENGTH]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
//				info.BorderStyle = getAttrValue(node,
//						cszAttribName[BORDERSTYLE]);
//				if(info.BorderStyle == null || info.BorderStyle.isEmpty())
//					info.BorderStyle = cszBorderStyle[0];
                info.groupStyle = getAttrValue(node,
                    cszAttribName[GROUPSTYLE]);
                if(info.groupStyle == null || info.groupStyle.isEmpty())
                    info.groupStyle = cszGroupStyle[GROUP_STYLE_NONE];
            
				info.limitLength = value;
				info.inputStyle = getAttrValue(node, cszAttribName[INPUTSTYLE]);
				info.titleText = getAttrValue(node, cszAttribName[TITLETEXT]);
				info.ShowTitleText = getAttrValue(node,
						cszAttribName[SHOWTITLETEXT]);
				if(info.ShowTitleText == null || info.ShowTitleText.isEmpty())
					info.ShowTitleText = "FALSE";
					
				info.KeypadEnabled = getAttrValue(node,
						cszAttribName[KEYPADENABLED]);
				if(info.KeypadEnabled == null || info.KeypadEnabled.isEmpty())
					info.KeypadEnabled = "TRUE";

				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getExpandableListInfo(Node parent, EXPANDABLELIST_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.itemDivider = getAttrValue(node,
						cszAttribName[ITEMDIVIDER]);
                String s = getAttrValue(node, cszAttribName[COLOROFEMPTYLISTTEXT]);
                if (s == null || s.isEmpty())
                    info.colorOfEmptyListText = DEFAULT_COLOR;
                else
                    info.colorOfEmptyListText = s;
				info.textOfEmptyList = getAttrValue(node,
						cszAttribName[TEXTOFEMPTYLIST]);
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getFlashInfo(Node parent, FLASHCONTROL_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.localFilePath = getAttrValue(node,
						cszAttribName[LOCALFILEPATH]);
				info.urlFilePath = getAttrValue(node,
						cszAttribName[URLFILEPATH]);
				info.quality = getAttrValue(node, cszAttribName[QUALITY]);
				info.repeatMode = getAttrValue(node, cszAttribName[REPEATMODE]);
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getGroupedListInfo(Node parent, GROUPEDLIST_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.itemDivider = getAttrValue(node,
						cszAttribName[ITEMDIVIDER]);
				info.fastScroll = getAttrValue(node, cszAttribName[FASTSCROLL]);
                String s = getAttrValue(node, cszAttribName[COLOROFEMPTYLISTTEXT]);
                if (s == null || s.isEmpty())
                    info.colorOfEmptyListText = DEFAULT_COLOR;
                else
                    info.colorOfEmptyListText = s;
				info.textOfEmptyList = getAttrValue(node,
						cszAttribName[TEXTOFEMPTYLIST]);
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getIconListInfo(Node parent, ICONLIST_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;
		int value;
		String s;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				s = getAttrValue(node, cszAttribName[ITEMWIDTH]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 60;
				}
				info.itemWidth = value;
				s = getAttrValue(node, cszAttribName[ITEMHEIGHT]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 60;
				}
				info.itemHeight = value;
                s = getAttrValue(node, cszAttribName[COLOROFEMPTYLISTTEXT]);
                if (s == null || s.isEmpty())
                    info.colorOfEmptyListText = DEFAULT_COLOR;
                else
                    info.colorOfEmptyListText = s;
                info.textOfEmptyList = getAttrValue(node,
                        cszAttribName[TEXTOFEMPTYLIST]);
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getLabelIfno(Node parent, LABEL_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;
		int value;
		String s;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.text = getAttrValue(node, cszAttribName[TEXT]);

				info.hAlign = getAttrValue(node, cszAttribName[HALIGN]);
				if (info.hAlign == null || info.hAlign.isEmpty())
					info.hAlign = cszHAlign[1];
				info.vAlign = getAttrValue(node, cszAttribName[VALIGN]);
				if (info.vAlign == null || info.vAlign.isEmpty())
					info.vAlign = cszVAlign[1];

				info.bgBitmap = getBmpPath(getAttrValue(node, cszAttribName[BGBITMAPPATH]));

				s = getAttrValue(node, cszAttribName[BGCOLOR]);
				if (s == null || s.isEmpty())
					info.bgColor = DEFAULT_COLOR;
				else
					info.bgColor = s;

				s = getAttrValue(node, cszAttribName[TEXTCOLOR]);
				if (s == null || s.isEmpty())
					info.textColor = DEFAULT_COLOR;
				else
					info.textColor = s;

				s = getAttrValue(node, cszAttribName[TEXTSIZE]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				info.textSize = value;

				info.textStyle = getAttrValue(node, cszAttribName[TEXTSTYLE]);

				s = getAttrValue(node, cszAttribName[BGCOLOROPACITY]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				if(isScotia())
					info.bgColorOpacity = 100;
				else
					info.bgColorOpacity = value;
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getListInfo(Node parent, LIST_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;
		int value;
		String s;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.ListItemFormat = getAttrValue(node,
						cszAttribName[LISTITEMFORMAT]);
				s = getAttrValue(node, cszAttribName[LINE1HEIGHT]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 80;
				}
				info.line1Height = value;
				s = getAttrValue(node, cszAttribName[ROW1HEIGHT]);
				if (s != null && !s.isEmpty()) {
					try {
						value = Integer.parseInt(s);
					} catch (NumberFormatException e) {
						value = 80;
					}
					info.line1Height = value;
				}
				s = getAttrValue(node, cszAttribName[LINE2HEIGHT]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 50;
				}
				info.line2Height = value;
				s = getAttrValue(node, cszAttribName[ROW2HEIGHT]);
				if (s != null && !s.isEmpty()) {
					try {
						value = Integer.parseInt(s);
					} catch (NumberFormatException e) {
						value = 50;
					}
					info.line2Height = value;
				}
				s = getAttrValue(node, cszAttribName[COLUMN1WIDTH]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 50;
				}
				if(value == 0)
				    value = 50;
				info.colume1Width = value;
				s = getAttrValue(node, cszAttribName[COLUMN2WIDTH]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 50;
				}
                if(value == 0)
                    value = 50;
				info.colume2Width = value;

                s = getAttrValue(node, cszAttribName[COLOROFEMPTYLISTTEXT]);
                if (s == null || s.isEmpty())
                    info.colorOfEmptyListText = DEFAULT_COLOR;
                else
                    info.colorOfEmptyListText = s;
				info.textOfEmptyList = getAttrValue(node,
						cszAttribName[TEXTOFEMPTYLIST]);
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getOverlayPanelInfo(Node parent, OVERLAYPANEL_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;
		int value;
		String s = null;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
//				s = getAttrValue(node, cszAttribName[BGCOLOR]);
				if (s == null || s.isEmpty())
					info.bgColor = DEFAULT_COLOR;
				else
					info.bgColor = s;
//				s = getAttrValue(node, cszAttribName[BGCOLOROPACITY]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				info.bgColorOpacity = value;
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getPanelInfo(Node parent, PANEL_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;
		int value;
		String s;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				s = getAttrValue(node, cszAttribName[BGCOLOR]);
				if (s == null || s.isEmpty())
					info.bgColor = DEFAULT_COLOR;
				else
					info.bgColor = s;
//				info.BorderStyle = getAttrValue(node,
//						cszAttribName[BORDERSTYLE]);
//				if(info.BorderStyle == null || info.BorderStyle.isEmpty())
//					info.BorderStyle = cszBorderStyle[0];
				
                info.groupStyle = getAttrValue(node,
                    cszAttribName[GROUPSTYLE]);
                if(info.groupStyle == null || info.groupStyle.isEmpty())
                    info.groupStyle = cszGroupStyle[GROUP_STYLE_NONE];
            
				s = getAttrValue(node, cszAttribName[BGCOLOROPACITY]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				if(isScotia())
					info.bgColorOpacity = 100;
				else
					info.bgColorOpacity = value;
				
                if (!info.groupStyle.equals(cszGroupStyle[GROUP_STYLE_NONE])) {
                    info.bgColorOpacity = 100;
                    info.bgColor = OspResourceManager.ColorToString(new Color(null, 0, 0, 0));
                }
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getProgressInfo(Node parent, PROGRESS_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;
		int value;
		String s;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				s = getAttrValue(node, cszAttribName[VALUE]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				info.value = value;
				s = getAttrValue(node, cszAttribName[MIN]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				info.min = value;
				s = getAttrValue(node, cszAttribName[MAX]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				info.max = value;

				s = getAttrValue(node, cszAttribName[BGCOLOR]);
				if (s == null || s.isEmpty())
					info.bgColor = DEFAULT_COLOR;
				else
					info.bgColor = s;

				info.leftText = getAttrValue(node, cszAttribName[LEFTTEXT]);
				info.rightText = getAttrValue(node, cszAttribName[RIGHTTEXT]);
				s = getAttrValue(node, cszAttribName[BSHOWVALUESTATE]);
				if (s == null || s.isEmpty() || s.equals(BOOL[BOOL_TRUE]))
					info.bShowValueState = true;
				else
					info.bShowValueState = false;
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getSGListInfo(Node parent, SLIDABLEGROUPEDLIST_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.itemDivider = getAttrValue(node,
						cszAttribName[ITEMDIVIDER]);
				info.fastScroll = getAttrValue(node, cszAttribName[FASTSCROLL]);
                String s = getAttrValue(node, cszAttribName[COLOROFEMPTYLISTTEXT]);
                if (s == null || s.isEmpty())
                    info.colorOfEmptyListText = DEFAULT_COLOR;
                else
                    info.colorOfEmptyListText = s;
				info.textOfEmptyList = getAttrValue(node,
						cszAttribName[TEXTOFEMPTYLIST]);
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getSListInfo(Node parent, SLIDABLELIST_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.itemDivider = getAttrValue(node,
						cszAttribName[ITEMDIVIDER]);
                String s = getAttrValue(node, cszAttribName[COLOROFEMPTYLISTTEXT]);
                if (s == null || s.isEmpty())
                    info.colorOfEmptyListText = DEFAULT_COLOR;
                else
                    info.colorOfEmptyListText = s;
				info.textOfEmptyList = getAttrValue(node,
						cszAttribName[TEXTOFEMPTYLIST]);
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getSliderInfo(Node parent, SLIDER_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;
		int value;
		String s;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				s = getAttrValue(node, cszAttribName[VALUE]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				info.value = value;
				s = getAttrValue(node, cszAttribName[MIN]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				info.min = value;
				s = getAttrValue(node, cszAttribName[MAX]);
				try {
					value = Integer.parseInt(s);
				} catch (NumberFormatException e) {
					value = 0;
				}
				info.max = value;
				info.titleText = getAttrValue(node, cszAttribName[TITLETEXT]);
                s = getAttrValue(node, cszAttribName[COLOROFTITLETEXT]);
                if (s == null || s.isEmpty())
                    info.titleTextColor = DEFAULT_COLOR;
                else
                    info.titleTextColor = s;
				info.ShowTitleText = getAttrValue(node,
						cszAttribName[SHOWTITLETEXT]);
				if(info.ShowTitleText == null || info.ShowTitleText.isEmpty())
					info.ShowTitleText = "FALSE";
//				info.BorderStyle = getAttrValue(node,
//						cszAttribName[BORDERSTYLE]);
//				if(info.BorderStyle == null || info.BorderStyle.isEmpty())
//					info.BorderStyle = cszBorderStyle[0];	
				
                info.groupStyle = getAttrValue(node,
                    cszAttribName[GROUPSTYLE]);
                if(info.groupStyle == null || info.groupStyle.isEmpty())
                    info.groupStyle = cszGroupStyle[GROUP_STYLE_NONE];
            
                s = getAttrValue(node, cszAttribName[BACKGROUNDSTYLE]);
                if (!info.groupStyle.equals(cszGroupStyle[GROUP_STYLE_NONE])) {
                    s = cszBgStyle[BACKGROUND_STYLE_DEFAULT];
                }
                info.BgStyle = s;
                
				if(info.BgStyle == null || info.BgStyle.isEmpty())
					info.BgStyle = cszBgStyle[BACKGROUND_STYLE_NONE];
				
				s = getAttrValue(node, cszAttribName[BGCOLOR]);
				if (s == null || s.isEmpty())
					info.bgColor = DEFAULT_COLOR;
				else
					info.bgColor = s;

				info.leftIconBitmapPath = getBmpPath(getAttrValue(node,
						cszAttribName[LEFTICONBITMAPPATH]));
				info.rightIconBitmapPath = getBmpPath(getAttrValue(node,
						cszAttribName[RIGHTICONBITMAPPATH]));
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	private void getTimepickerInfo(Node parent, TIMEPICKER_INFO info) {
		NamedNodeMap namedMap = parent.getAttributes();
		if (namedMap == null)
			return;

		for (Node node = parent.getFirstChild(); node != null; node = node
				.getNextSibling()) {
			int index = getAttrIndex(node.getNodeName());
			switch (index) {
			case PROPERTY:
				info.titleText = getAttrValue(node, cszAttribName[TITLETEXT]);
				break;
			case LAYOUT:
				getLayout(node, info);
				break;
			}
		}
	}

	protected abstract void getLayout(Node node, ITEM_INFO info);

	private String DOCTYPE_SYSTEM = "<!DOCTYPE";
	
    /**
     * @param dom
     * @param element
     * @param comment
     */
    protected void appandComment(Document dom, Document element, String comment) {
        String newLine = System.getProperty("line.separator", "\n");
        comment = newLine + comment + newLine;
        Comment node = dom.createComment(comment);
        
        element.appendChild(node);
    }

	protected String write(Document dom) {
		TransformerFactory factory = TransformerFactory.newInstance();
		factory.setAttribute("indent-number", Integer.valueOf(4));

		StringWriter sw = null;
		try {
			sw = new StringWriter();
			Transformer transformer = factory.newTransformer();

			transformer.setOutputProperty(OutputKeys.METHOD, "xml"); //$NON-NLS-1$ 
			//$NON-NLS-1$ 
			transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8"); //$NON-NLS-1$ 
			transformer.setOutputProperty(OutputKeys.INDENT, "yes"); //$NON-NLS-1$ 
			transformer.setOutputProperty(
					"{http://xml.apache.org/xslt}indent-amount", String
							.valueOf(4));

			transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, DTD_NAME);

			transformer.transform(new DOMSource(dom), new StreamResult(sw));

			String retString = sw.getBuffer().toString();
			if(retString.indexOf(DOCTYPE_SYSTEM) >= 0)
			    retString = retString.replace(DOCTYPE_SYSTEM, System.getProperty("line.separator", "\n") + DOCTYPE_SYSTEM);
			return retString;

		} catch (TransformerConfigurationException e) {
			Activator.setErrorMessage("OspMarkup.write()", e.getClass() + " - "
					+ e.getMessage(), e);
		} catch (TransformerException e) {
			Activator.setErrorMessage("OspMarkup.write()", e.getClass() + " - "
					+ e.getMessage(), e);
		} finally {
			try {
				if (sw != null)
					sw.close();
			} catch (IOException e) {
				Activator.setErrorMessage("OspMarkup.write()", "finally] "
						+ e.getClass() + " - " + e.getMessage(), e);
			}
		}

		return null;
	}

	protected void appandButtonInfo(Document dom, Element parent,
			BUTTON_INFO info) {
		String s;

		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[TEXT], info.text);

		s = info.hAlign;
		if (s == null || s.isEmpty())
			s = cszHAlign[1];
		element.setAttribute(cszAttribName[HALIGN], s);
		s = info.vAlign;
		if (s == null || s.isEmpty())
			s = cszVAlign[1];
		element.setAttribute(cszAttribName[VALIGN], s);

		if (info.normalFGColor.equals(DEFAULT_COLOR))
			element.setAttribute(cszAttribName[NOMALTEXTCOLOR], "");
		else
			element.setAttribute(cszAttribName[NOMALTEXTCOLOR],
					info.normalFGColor);

		if (info.pressedFGColor.equals(DEFAULT_COLOR))
			element.setAttribute(cszAttribName[PRESSEDTEXTCOLOR], "");
		else
			element.setAttribute(cszAttribName[PRESSEDTEXTCOLOR],
					info.pressedFGColor);

		if (info.disableFGColor.equals(DEFAULT_COLOR))
			element.setAttribute(cszAttribName[DISABLETEXTCOLOR], "");
		else
			element.setAttribute(cszAttribName[DISABLETEXTCOLOR],
					info.disableFGColor);

//		element.setAttribute(cszAttribName[NORMALBITMAPPATH],
//				info.normalBitmapPath);
//
//		element.setAttribute(cszAttribName[PRESSEDBITMAPPATH],
//				info.pressedBitmapPath);
//
//		element.setAttribute(cszAttribName[DISABLEDBITMAPPATH],
//				info.disabledBitmapPath);

		element.setAttribute(cszAttribName[NORMALBGBITMAPPATH],
			    getBmpPath(info.normalBGBitmapPath));
		element.setAttribute(cszAttribName[PRESSEDBGBITMAPPATH],
			    getBmpPath(info.pressedBGBitmapPath));

		parent.appendChild(element);
	}

	protected void appandCheckInfo(Document dom, Element parent, CHECK_INFO info) {
		String s;
		Element element = dom.createElement(cszAttribName[PROPERTY]);

		element.setAttribute(cszAttribName[TEXT], info.text);
        if (info.textColor.equals(DEFAULT_COLOR))
            element.setAttribute(cszAttribName[COLOROFTEXT], "");
        else
            element.setAttribute(cszAttribName[COLOROFTEXT],
                    info.textColor);
		s = Integer.toString(info.GroupID);
		element.setAttribute(cszAttribName[GROUPID], s);
		element.setAttribute(cszAttribName[BACKGROUNDSTYLE], info.BgStyle);
        element.setAttribute(cszAttribName[GROUPSTYLE], info.groupStyle);
		element.setAttribute(cszAttribName[TITLETEXT], info.titleText);
        if (info.titleTextColor.equals(DEFAULT_COLOR))
            element.setAttribute(cszAttribName[COLOROFTITLETEXT], "");
        else
            element.setAttribute(cszAttribName[COLOROFTITLETEXT],
                    info.titleTextColor);
        
		element
				.setAttribute(cszAttribName[SHOWTITLETEXT],
						info.ShowTitleText);
		s = info.hAlign;
		if (s == null || s.isEmpty())
			s = cszHAlign[0];
		element.setAttribute(cszAttribName[HALIGN], s);
		s = info.vAlign;
		if (s == null || s.isEmpty())
			s = cszVAlign[0];
		element.setAttribute(cszAttribName[VALIGN], s);
		//element.setAttribute(cszAttribName[BORDERSTYLE], info.BorderStyle);
		parent.appendChild(element);
	}

	protected void appandColorPickerInfo(Document dom, Element parent,
			COLORPICKER_INFO info) {
	}
	
	protected void appandCustomListInfo(Document dom, Element parent,
			CUSTOMLIST_INFO info) {
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[ITEMDIVIDER], info.itemDivider);
        if (info.colorOfEmptyListText.equals(DEFAULT_COLOR))
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT], "");
        else
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT],
                    info.colorOfEmptyListText);
		element.setAttribute(cszAttribName[TEXTOFEMPTYLIST],
				info.textOfEmptyList);

		parent.appendChild(element);
	}

	protected void appandDatePickerInfo(Document dom, Element parent,
			DATEPICKER_INFO info) {
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[TITLETEXT], info.titleText);
		parent.appendChild(element);
	}

	protected void appandEditAreaIfno(Document dom, Element parent,
			EDITAREA_INFO info) {
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[GUIDETEXT], info.guideText);
		element.setAttribute(cszAttribName[TEXT], info.text);
		element.setAttribute(cszAttribName[LIMITLENGTH], Integer
				.toString(info.limitLength));
		element.setAttribute(cszAttribName[INPUTSTYLE], info.inputStyle);

		parent.appendChild(element);
	}

	protected void appandEditFieldInfo(Document dom, Element parent,
			EDITFIELD_INFO info) {
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[GUIDETEXT], info.guideText);
		element.setAttribute(cszAttribName[TEXT], info.text);
		//element.setAttribute(cszAttribName[BORDERSTYLE], info.BorderStyle);
		element.setAttribute(cszAttribName[LIMITLENGTH], Integer
				.toString(info.limitLength));
		element.setAttribute(cszAttribName[TITLETEXT], info.titleText);
		element
				.setAttribute(cszAttribName[SHOWTITLETEXT],
						info.ShowTitleText);
		element
				.setAttribute(cszAttribName[KEYPADENABLED],
						info.KeypadEnabled);
		element.setAttribute(cszAttribName[INPUTSTYLE], info.inputStyle);
        element.setAttribute(cszAttribName[GROUPSTYLE], info.groupStyle);

		parent.appendChild(element);
	}

	protected void appandExpandableListInfo(Document dom, Element parent,
			EXPANDABLELIST_INFO info) {
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[ITEMDIVIDER], info.itemDivider);
        if (info.colorOfEmptyListText.equals(DEFAULT_COLOR))
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT], "");
        else
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT],
                    info.colorOfEmptyListText);
		element.setAttribute(cszAttribName[TEXTOFEMPTYLIST],
				info.textOfEmptyList);

		parent.appendChild(element);
	}

	protected void appandFlashInfo(Document dom, Element parent,
			FLASHCONTROL_INFO info) {
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[LOCALFILEPATH], info.localFilePath);
		element.setAttribute(cszAttribName[URLFILEPATH], info.urlFilePath);
		element.setAttribute(cszAttribName[QUALITY], info.quality);
		element.setAttribute(cszAttribName[REPEATMODE], info.repeatMode);

		parent.appendChild(element);
	}

	protected void appandGroupedListInfo(Document dom, Element parent,
			GROUPEDLIST_INFO info) {
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[ITEMDIVIDER], info.itemDivider);
		element.setAttribute(cszAttribName[FASTSCROLL], info.fastScroll);
        if (info.colorOfEmptyListText.equals(DEFAULT_COLOR))
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT], "");
        else
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT],
                    info.colorOfEmptyListText);
		element.setAttribute(cszAttribName[TEXTOFEMPTYLIST],
				info.textOfEmptyList);

		parent.appendChild(element);
	}

	protected void appandIconListInfo(Document dom, Element parent,
			ICONLIST_INFO info) {
		String s;
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		s = Integer.toString(info.itemWidth);
		element.setAttribute(cszAttribName[ITEMWIDTH], s);
		s = Integer.toString(info.itemHeight);
		element.setAttribute(cszAttribName[ITEMHEIGHT], s);
        if (info.colorOfEmptyListText.equals(DEFAULT_COLOR))
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT], "");
        else
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT],
                    info.colorOfEmptyListText);
        element.setAttribute(cszAttribName[TEXTOFEMPTYLIST],
                info.textOfEmptyList);

		parent.appendChild(element);
	}

	protected void appandLabelIfno(Document dom, Element parent, LABEL_INFO info) {
		String s;
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[TEXT], info.text);

		element.setAttribute(cszAttribName[BGBITMAPPATH], getBmpPath(info.bgBitmap));

		if (info.bgColor.equals(DEFAULT_COLOR))
			element.setAttribute(cszAttribName[BGCOLOR], "");
		else
			element.setAttribute(cszAttribName[BGCOLOR], info.bgColor);

		if (info.textColor.equals(DEFAULT_COLOR))
			element.setAttribute(cszAttribName[TEXTCOLOR], "");
		else
			element.setAttribute(cszAttribName[TEXTCOLOR], info.textColor);

		s = Integer.toString(info.textSize);
		element.setAttribute(cszAttribName[TEXTSIZE], s);

		element.setAttribute(cszAttribName[TEXTSTYLE], info.textStyle);

		s = info.hAlign;
		if (s == null || s.isEmpty())
			s = cszHAlign[0];
		element.setAttribute(cszAttribName[HALIGN], s);
		s = info.vAlign;
		if (s == null || s.isEmpty())
			s = cszVAlign[0];
		element.setAttribute(cszAttribName[VALIGN], s);

		s = Integer.toString(info.bgColorOpacity);
		element.setAttribute(cszAttribName[BGCOLOROPACITY], s);

		parent.appendChild(element);
	}

	protected void appandListInfo(Document dom, Element parent, LIST_INFO info) {
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element
				.setAttribute(cszAttribName[LISTITEMFORMAT],
						info.ListItemFormat);
		element.setAttribute(cszAttribName[ROW1HEIGHT], Integer
				.toString(info.line1Height));
		element.setAttribute(cszAttribName[ROW2HEIGHT], Integer
				.toString(info.line2Height));
		element.setAttribute(cszAttribName[COLUMN1WIDTH], Integer
				.toString(info.colume1Width));
		element.setAttribute(cszAttribName[COLUMN2WIDTH], Integer
				.toString(info.colume2Width));
        if (info.colorOfEmptyListText.equals(DEFAULT_COLOR))
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT], "");
        else
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT],
                    info.colorOfEmptyListText);
		element.setAttribute(cszAttribName[TEXTOFEMPTYLIST],
				info.textOfEmptyList);

		parent.appendChild(element);
	}

	protected void appandOverlayPanelInfo(Document dom, Element parent,
			OVERLAYPANEL_INFO info) {
//		String s;
		Element element = dom.createElement(cszAttribName[PROPERTY]);
//		if (info.bgColor.equals(DEFAULT_COLOR))
//			element.setAttribute(cszAttribName[BGCOLOR], "");
//		else
//			element.setAttribute(cszAttribName[BGCOLOR], info.bgColor);
//		s = Integer.toString(info.bgColorOpacity);
//		element.setAttribute(cszAttribName[BGCOLOROPACITY], s);

		parent.appendChild(element);
	}

	protected void appandPanelInfo(Document dom, Element parent, PANEL_INFO info) {
		String s;
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		if (info.bgColor.equals(DEFAULT_COLOR))
			element.setAttribute(cszAttribName[BGCOLOR], "");
		else
			element.setAttribute(cszAttribName[BGCOLOR], info.bgColor);
//		element.setAttribute(cszAttribName[BORDERSTYLE], info.BorderStyle);
        element.setAttribute(cszAttribName[GROUPSTYLE], info.groupStyle);
		s = Integer.toString(info.bgColorOpacity);
		element.setAttribute(cszAttribName[BGCOLOROPACITY], s);

		parent.appendChild(element);
	}

	protected void appandProgressInfo(Document dom, Element parent,
			PROGRESS_INFO info) {
		String s;
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		s = Integer.toString(info.value);
		element.setAttribute(cszAttribName[VALUE], s);
		s = Integer.toString(info.min);
		element.setAttribute(cszAttribName[MIN], s);
		s = Integer.toString(info.max);
		element.setAttribute(cszAttribName[MAX], s);

		if (info.bgColor.equals(DEFAULT_COLOR))
			element.setAttribute(cszAttribName[BGCOLOR], "");
		else
			element.setAttribute(cszAttribName[BGCOLOR], info.bgColor);

		element.setAttribute(cszAttribName[LEFTTEXT], info.leftText);
		element.setAttribute(cszAttribName[RIGHTTEXT], info.rightText);

		if (info.bShowValueState)
			element.setAttribute(cszAttribName[BSHOWVALUESTATE],
					BOOL[BOOL_TRUE]);
		else
			element.setAttribute(cszAttribName[BSHOWVALUESTATE],
					BOOL[BOOL_FALSE]);

		parent.appendChild(element);
	}

	protected void appandSGListInfo(Document dom, Element parent,
			SLIDABLEGROUPEDLIST_INFO info) {
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[ITEMDIVIDER], info.itemDivider);
		element.setAttribute(cszAttribName[FASTSCROLL], info.fastScroll);
        if (info.colorOfEmptyListText.equals(DEFAULT_COLOR))
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT], "");
        else
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT],
                    info.colorOfEmptyListText);
		element.setAttribute(cszAttribName[TEXTOFEMPTYLIST],
				info.textOfEmptyList);

		parent.appendChild(element);
	}

	protected void appandSListInfo(Document dom, Element parent,
			SLIDABLELIST_INFO info) {
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[ITEMDIVIDER], info.itemDivider);
        if (info.colorOfEmptyListText.equals(DEFAULT_COLOR))
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT], "");
        else
            element.setAttribute(cszAttribName[COLOROFEMPTYLISTTEXT],
                    info.colorOfEmptyListText);
		element.setAttribute(cszAttribName[TEXTOFEMPTYLIST],
				info.textOfEmptyList);

		parent.appendChild(element);
	}

	protected void appandSliderInfo(Document dom, Element parent,
			SLIDER_INFO info) {
		String s;
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		s = Integer.toString(info.value);
		element.setAttribute(cszAttribName[VALUE], s);
		s = Integer.toString(info.min);
		element.setAttribute(cszAttribName[MIN], s);
		s = Integer.toString(info.max);
		element.setAttribute(cszAttribName[MAX], s);
		element.setAttribute(cszAttribName[TITLETEXT], info.titleText);
        if (info.titleTextColor.equals(DEFAULT_COLOR))
            element.setAttribute(cszAttribName[COLOROFTITLETEXT], "");
        else
            element.setAttribute(cszAttribName[COLOROFTITLETEXT],
                    info.titleTextColor);
		element
				.setAttribute(cszAttribName[SHOWTITLETEXT],
						info.ShowTitleText);
//		element.setAttribute(cszAttribName[BORDERSTYLE], info.BorderStyle);
        element.setAttribute(cszAttribName[GROUPSTYLE], info.groupStyle);
		element.setAttribute(cszAttribName[BACKGROUNDSTYLE], info.BgStyle);

		if (info.bgColor.equals(DEFAULT_COLOR))
			element.setAttribute(cszAttribName[BGCOLOR], "");
		else
			element.setAttribute(cszAttribName[BGCOLOR], info.bgColor);

		element.setAttribute(cszAttribName[LEFTICONBITMAPPATH],
			    getBmpPath(info.leftIconBitmapPath));
		element.setAttribute(cszAttribName[RIGHTICONBITMAPPATH],
			    getBmpPath(info.rightIconBitmapPath));

		parent.appendChild(element);
	}

	protected void appandTimepickerInfo(Document dom, Element parent,
			TIMEPICKER_INFO info) {
		Element element = dom.createElement(cszAttribName[PROPERTY]);
		element.setAttribute(cszAttribName[TITLETEXT], info.titleText);
		parent.appendChild(element);
	}

}
